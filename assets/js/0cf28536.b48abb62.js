"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3902],{1690:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"module-1-ros2/chapter-3-services-clients","title":"ROS 2 Services and Clients","description":"Learning Objectives","source":"@site/docs/module-1-ros2/chapter-3-services-clients.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-3-services-clients","permalink":"/RoboBook/docs/module-1-ros2/chapter-3-services-clients","draft":false,"unlisted":false,"editUrl":"https://github.com/NeelamGhazal/RoboBook/tree/main/docs/module-1-ros2/chapter-3-services-clients.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"ROS 2 Services and Clients","sidebar_position":4},"sidebar":"textbookSidebar","previous":{"title":"Chapter 2: Topics & Pub/Sub","permalink":"/RoboBook/docs/module-1-ros2/chapter-2-topics-pubsub"},"next":{"title":"Chapter 4: rclpy Python Client","permalink":"/RoboBook/docs/module-1-ros2/chapter-4-rclpy-python-client"}}');var i=s(4848),t=s(8453);const c={title:"ROS 2 Services and Clients",sidebar_position:4},l="ROS 2 Services and Clients",o={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Knowledge Prerequisites",id:"knowledge-prerequisites",level:3},{value:"Software Prerequisites",id:"software-prerequisites",level:3},{value:"Installation Verification",id:"installation-verification",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Theory",id:"theory",level:2},{value:"The Request-Response Pattern",id:"the-request-response-pattern",level:3},{value:"Services vs. Topics",id:"services-vs-topics",level:3},{value:"Service Architecture",id:"service-architecture",level:3},{value:"Service Types and Message Structure",id:"service-types-and-message-structure",level:3},{value:"Service Commands",id:"service-commands",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Service Server",id:"service-server",level:3},{value:"Service Client",id:"service-client",level:3},{value:"Running the Example",id:"running-the-example",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Custom Service",id:"exercise-1-custom-service",level:3},{value:"Exercise 2: Service Integration",id:"exercise-2-service-integration",level:3},{value:"Exercise 3: Error Handling",id:"exercise-3-error-handling",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-services-and-clients",children:"ROS 2 Services and Clients"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Explain the request-response communication pattern in ROS 2 services"}),"\n",(0,i.jsx)(n.li,{children:"Implement a service server that responds to requests"}),"\n",(0,i.jsx)(n.li,{children:"Implement a client that sends requests to services"}),"\n",(0,i.jsx)(n.li,{children:"Compare and contrast services with topics for different use cases"}),"\n",(0,i.jsx)(n.li,{children:"Analyze service communication in a running ROS 2 system"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.h3,{id:"knowledge-prerequisites",children:"Knowledge Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ROS 2 Nodes"}),": Understanding of ROS 2 node structure and lifecycle (Chapter 1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Python Programming"}),": Basic understanding of classes, methods, and imports"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topics & Publishers/Subscribers"}),": Understanding of pub/sub pattern (Chapter 2)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physical AI Concepts"}),": Understanding of Physical AI fundamentals from Chapter 0 (intro.md)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"software-prerequisites",children:"Software Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Operating System"}),": Ubuntu 22.04 LTS with ROS 2 Humble Hawksbill installed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Python"}),": Version 3.10 or higher"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal"}),": Bash shell access"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"installation-verification",children:"Installation Verification"}),"\n",(0,i.jsx)(n.p,{children:"Verify your ROS 2 installation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"source /opt/ros/humble/setup.bash\nros2 service --help\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expected output: Help text for the ros2 service command."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"In the previous chapters, we explored nodes (Chapter 1) and the publish-subscribe pattern for asynchronous communication (Chapter 2). While topics excel at broadcasting sensor data and distributing information to multiple subscribers, many robot operations require synchronous request-response interactions. This is where ROS 2 services come into play."}),"\n",(0,i.jsx)(n.p,{children:'Consider asking a friend for directions: you ask a specific question ("How do I get to the library?"), they process your request, and they provide a specific response. This is fundamentally different from a radio broadcast where the station continuously sends information without expecting individual responses. Services in ROS 2 provide this request-response communication pattern, enabling synchronous interactions between nodes.'}),"\n",(0,i.jsx)(n.p,{children:"In Physical AI systems, services are essential for operations that require immediate responses or have specific outcomes: requesting a robot to move to a specific location and waiting for confirmation, asking a sensor for its current configuration, or commanding a gripper to open or close. Unlike topics, which are asynchronous and broadcast to all subscribers, services provide synchronous, point-to-point communication with guaranteed responses."}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, we'll explore the service-client pattern, implement both service servers and clients, and understand when to use services versus topics in Physical AI systems."}),"\n",(0,i.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.h3,{id:"the-request-response-pattern",children:"The Request-Response Pattern"}),"\n",(0,i.jsx)(n.p,{children:"The request-response pattern is a synchronous communication paradigm where:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client"})," sends a request to a service"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service"})," processes the request and generates a response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client"})," receives the response and continues execution"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This pattern is characterized by:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Synchronous"}),": Client waits for response before continuing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Point-to-point"}),": Direct communication between client and service"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Guaranteed response"}),": Every request receives exactly one response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request-response coupling"}),": Request and response types are predefined"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"services-vs-topics",children:"Services vs. Topics"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Topics (Publish-Subscribe)"}),(0,i.jsx)(n.th,{children:"Services (Request-Response)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Timing"})}),(0,i.jsx)(n.td,{children:"Asynchronous"}),(0,i.jsx)(n.td,{children:"Synchronous"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Coupling"})}),(0,i.jsx)(n.td,{children:"Loose (publisher doesn't know subscribers)"}),(0,i.jsx)(n.td,{children:"Tight (client knows service)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Response"})}),(0,i.jsx)(n.td,{children:"No response guaranteed"}),(0,i.jsx)(n.td,{children:"Response guaranteed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"Sensor data, status updates"}),(0,i.jsx)(n.td,{children:"Actions, queries, commands"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Scalability"})}),(0,i.jsx)(n.td,{children:"Many-to-many"}),(0,i.jsx)(n.td,{children:"One-to-one"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"service-architecture",children:"Service Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The service architecture involves two main components:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:'%%{title: "ROS 2 Service Communication"}%%\nsequenceDiagram\n    participant C as Client\n    participant S as Service Server\n    C->>S: Request (with parameters)\n    S--\x3e>C: Response (with results)\n'})}),"\n",(0,i.jsx)(n.p,{children:"When a client sends a request to a service, it waits for the service to process the request and return a response. This synchronous behavior is essential for operations that must complete before the client can proceed."}),"\n",(0,i.jsx)(n.h3,{id:"service-types-and-message-structure",children:"Service Types and Message Structure"}),"\n",(0,i.jsxs)(n.p,{children:["Services use ",(0,i.jsx)(n.code,{children:".srv"})," files to define the interface between request and response. A service definition has two parts:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request"}),": Parameters sent from client to service"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response"}),": Results sent from service to client"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For example, the standard ",(0,i.jsx)(n.code,{children:"AddTwoInts"})," service is defined as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# Request\nint64 a\nint64 b\n---\n# Response\nint64 sum\n"})}),"\n",(0,i.jsx)(n.p,{children:"This defines a service that accepts two integers and returns their sum."}),"\n",(0,i.jsx)(n.h3,{id:"service-commands",children:"Service Commands"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides command-line tools for inspecting services:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# List all active services\nros2 service list\n\n# Show service type\nros2 service type /service_name\n\n# Call a service from command line\nros2 service call /service_name service_type "{request: parameters}"\n\n# Show service information\nros2 service info /service_name\n'})}),"\n",(0,i.jsx)(n.p,{children:"These tools are valuable for debugging and understanding service interactions in Physical AI systems."}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.p,{children:"Let's implement both a service server and client to demonstrate the request-response pattern:"}),"\n",(0,i.jsx)(n.h3,{id:"service-server",children:"Service Server"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\n\nclass MinimalService(Node):\n    """\n    Service server that responds to requests to add two integers.\n    Demonstrates the basic pattern of creating a service and handling requests.\n    """\n\n    def __init__(self):\n        super().__init__(\'minimal_service\')\n\n        # Create a service that adds two integers\n        self.srv = self.create_service(\n            AddTwoInts,\n            \'add_two_ints\',\n            self.add_two_ints_callback\n        )\n\n        self.get_logger().info(\'Service server initialized\')\n\n    def add_two_ints_callback(self, request, response):\n        """\n        Callback function called when a request is received.\n        Processes the request and returns a response.\n        """\n        # Perform the addition\n        response.sum = request.a + request.b\n\n        # Log the operation\n        self.get_logger().info(\n            f\'Incoming request: {request.a} + {request.b} = {response.sum}\'\n        )\n\n        # Return the response\n        return response\n\n\ndef main(args=None):\n    """Main function to run the service server."""\n    rclpy.init(args=args)\n\n    minimal_service = MinimalService()\n\n    try:\n        rclpy.spin(minimal_service)\n    except KeyboardInterrupt:\n        minimal_service.get_logger().info(\'Interrupt received, shutting down...\')\n    finally:\n        minimal_service.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"service-client",children:"Service Client"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import sys\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\n\nclass MinimalClient(Node):\n    \"\"\"\n    Service client that sends requests to the add_two_ints service.\n    Demonstrates the basic pattern of creating a client and sending requests.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('minimal_client')\n\n        # Create a client for the 'add_two_ints' service\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n\n        # Wait for the service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n        self.get_logger().info('Client initialized and connected to service')\n\n    def send_request(self, a, b):\n        \"\"\"\n        Send a request to add two integers and return the future.\n        \"\"\"\n        # Create a request object\n        request = AddTwoInts.Request()\n        request.a = a\n        request.b = b\n\n        # Call the service asynchronously\n        self.get_logger().info(f'Sending request: {a} + {b}')\n        future = self.cli.call_async(request)\n        return future\n\n\ndef main(args=None):\n    \"\"\"Main function to run the client and send requests.\"\"\"\n    rclpy.init(args=args)\n\n    minimal_client = MinimalClient()\n\n    # Check if command line arguments are provided\n    if len(sys.argv) != 3:\n        print('Usage: python3 client.py <int1> <int2>')\n        return\n\n    # Parse command line arguments\n    try:\n        a = int(sys.argv[1])\n        b = int(sys.argv[2])\n    except ValueError:\n        print('Please provide two integers as arguments')\n        return\n\n    # Send the request\n    future = minimal_client.send_request(a, b)\n\n    try:\n        # Spin until the future is complete\n        rclpy.spin_until_future_complete(minimal_client, future)\n\n        # Get the response\n        response = future.result()\n\n        # Print the result\n        print(f'Result of {a} + {b} = {response.sum}')\n\n    except KeyboardInterrupt:\n        minimal_client.get_logger().info('Interrupt received, shutting down...')\n    finally:\n        minimal_client.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected Output (Service Server):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[INFO] [minimal_service]: Service server initialized\n[INFO] [minimal_service]: Incoming request: 2 + 3 = 5\n[INFO] [minimal_service]: Incoming request: 10 + 5 = 15\n^C[INFO] [minimal_service]: Interrupt received, shutting down...\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected Output (Service Client):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[INFO] [minimal_client]: Service not available, waiting again...\n[INFO] [minimal_client]: Client initialized and connected to service\n[INFO] [minimal_client]: Sending request: 2 + 3\nResult of 2 + 3 = 5\n"})}),"\n",(0,i.jsx)(n.h3,{id:"running-the-example",children:"Running the Example"}),"\n",(0,i.jsxs)(n.p,{children:["To run this example, save the service code as ",(0,i.jsx)(n.code,{children:"service_server.py"})," and the client code as ",(0,i.jsx)(n.code,{children:"service_client.py"}),", then execute:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Run the service server\nsource /opt/ros/humble/setup.bash\npython3 service_server.py\n\n# Terminal 2: Run the client (while server is running)\nsource /opt/ros/humble/setup.bash\npython3 service_client.py 2 3\n"})}),"\n",(0,i.jsx)(n.p,{children:"The client will send a request to add 2 and 3, the service will process it, and the client will receive and display the result."}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-custom-service",children:"Exercise 1: Custom Service"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task"}),": Create a custom service to control a robot's LED."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Define a custom service message ",(0,i.jsx)(n.code,{children:"SetLED.srv"})," with fields for LED ID and brightness (0-100)"]}),"\n",(0,i.jsx)(n.li,{children:"Implement a service server that simulates controlling an LED"}),"\n",(0,i.jsx)(n.li,{children:"Implement a client that sends requests to change LED brightness"}),"\n",(0,i.jsx)(n.li,{children:"Test the service with different brightness values"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success Criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Custom service message is properly defined"}),"\n",(0,i.jsx)(n.li,{children:"Service server processes LED control requests"}),"\n",(0,i.jsx)(n.li,{children:"Client successfully sends requests and receives responses"}),"\n",(0,i.jsx)(n.li,{children:"Service operates correctly with different brightness values"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-service-integration",children:"Exercise 2: Service Integration"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task"}),": Integrate services with the publisher/subscriber pattern from Chapter 2."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create a publisher that sends sensor data to a topic"}),"\n",(0,i.jsx)(n.li,{children:"Create a service that processes the latest sensor data when requested"}),"\n",(0,i.jsx)(n.li,{children:"Create a client that requests processed data from the service"}),"\n",(0,i.jsx)(n.li,{children:"Demonstrate how services can complement topics in a system"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success Criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Publisher continuously sends sensor data"}),"\n",(0,i.jsx)(n.li,{children:"Service responds to requests with processed data"}),"\n",(0,i.jsx)(n.li,{children:"Client receives and displays processed results"}),"\n",(0,i.jsx)(n.li,{children:"System demonstrates both communication patterns working together"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-3-error-handling",children:"Exercise 3: Error Handling"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task"}),": Implement robust error handling in service communication."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Add timeout handling to the client when waiting for service responses"}),"\n",(0,i.jsx)(n.li,{children:"Implement error responses in the service server for invalid inputs"}),"\n",(0,i.jsx)(n.li,{children:"Test behavior when the service is not available"}),"\n",(0,i.jsx)(n.li,{children:"Handle service call failures gracefully"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success Criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Client handles service timeouts appropriately"}),"\n",(0,i.jsx)(n.li,{children:"Service returns error responses for invalid inputs"}),"\n",(0,i.jsx)(n.li,{children:"System behaves predictably when services are unavailable"}),"\n",(0,i.jsx)(n.li,{children:"Error conditions are properly logged and handled"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Services provide the request-response communication pattern essential for synchronous interactions in ROS 2 systems. Unlike topics, which enable asynchronous broadcasting, services guarantee responses and enable direct client-service communication. This makes them ideal for operations requiring immediate results, such as robot commands, sensor queries, and action execution."}),"\n",(0,i.jsx)(n.p,{children:"We've implemented both service servers and clients, demonstrating the core concepts of creating services, handling requests, and sending responses. The example showed how clients send requests and wait for responses, creating synchronous interactions between nodes."}),"\n",(0,i.jsx)(n.p,{children:"Understanding when to use services versus topics is crucial for Physical AI system design. Use services for operations that require immediate responses or have specific outcomes, and use topics for continuous data distribution like sensor readings or status updates."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand both publish-subscribe and request-response communication patterns, the next chapter explores the rclpy Python client library in depth. You'll learn advanced features like parameters, quality of service settings, and lifecycle nodes that provide additional control over ROS 2 node behavior."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next Chapter"}),": ",(0,i.jsx)(n.a,{href:"/docs/module-1-ros2/chapter-4-rclpy-python-client",children:"Module 1, Chapter 4: rclpy Python Client Library"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>l});var r=s(6540);const i={},t=r.createContext(i);function c(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);