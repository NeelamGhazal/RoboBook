"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9206],{8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>o});var r=i(6540);const a={},s=r.createContext(a);function t(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),r.createElement(s.Provider,{value:e},n.children)}},9454:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-3-isaac/chapter-4-sim-to-real-principles","title":"Sim-to-Real Transfer Principles","description":"Learning Objectives","source":"@site/docs/module-3-isaac/chapter-4-sim-to-real-principles.md","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/chapter-4-sim-to-real-principles","permalink":"/RoboBook/docs/module-3-isaac/chapter-4-sim-to-real-principles","draft":false,"unlisted":false,"editUrl":"https://github.com/NeelamGhazal/RoboBook/tree/main/docs/module-3-isaac/chapter-4-sim-to-real-principles.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"title":"Sim-to-Real Transfer Principles","sidebar_position":15},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3: Nav2 Navigation Stack","permalink":"/RoboBook/docs/module-3-isaac/chapter-3-nav2-navigation"},"next":{"title":"Chapter 5: Domain Randomization","permalink":"/RoboBook/docs/module-3-isaac/chapter-5-domain-randomization"}}');var a=i(4848),s=i(8453);const t={title:"Sim-to-Real Transfer Principles",sidebar_position:15},o="Sim-to-Real Transfer Principles",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Knowledge Prerequisites",id:"knowledge-prerequisites",level:3},{value:"Software Prerequisites",id:"software-prerequisites",level:3},{value:"Installation Verification",id:"installation-verification",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Theory",id:"theory",level:2},{value:"The Reality Gap Problem",id:"the-reality-gap-problem",level:3},{value:"Domain Randomization",id:"domain-randomization",level:3},{value:"System Identification",id:"system-identification",level:3},{value:"Progressive Transfer",id:"progressive-transfer",level:3},{value:"Transfer Learning Approaches",id:"transfer-learning-approaches",level:3},{value:"Isaac Sim for Transfer",id:"isaac-sim-for-transfer",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Domain Randomization Script for Isaac Sim (domain_randomization.py)",id:"domain-randomization-script-for-isaac-sim-domain_randomizationpy",level:3},{value:"Isaac Sim Randomization Extension (randomization_extension.py)",id:"isaac-sim-randomization-extension-randomization_extensionpy",level:3},{value:"Transfer Evaluation Script (transfer_evaluation.py)",id:"transfer-evaluation-script-transfer_evaluationpy",level:3},{value:"Running the Example",id:"running-the-example",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Domain Randomization Effectiveness",id:"exercise-1-domain-randomization-effectiveness",level:3},{value:"Exercise 2: System Identification",id:"exercise-2-system-identification",level:3},{value:"Exercise 3: Progressive Transfer",id:"exercise-3-progressive-transfer",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"sim-to-real-transfer-principles",children:"Sim-to-Real Transfer Principles"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Explain the reality gap problem and its impact on robotics applications"}),"\n",(0,a.jsx)(e.li,{children:"Apply domain randomization techniques to improve sim-to-real transfer"}),"\n",(0,a.jsx)(e.li,{children:"Implement calibration methods to align simulation and reality"}),"\n",(0,a.jsx)(e.li,{children:"Evaluate transfer performance and identify failure modes"}),"\n",(0,a.jsx)(e.li,{children:"Design simulation environments that maximize transfer success"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsx)(e.h3,{id:"knowledge-prerequisites",children:"Knowledge Prerequisites"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ROS 2 Fundamentals"}),": Understanding of nodes, topics, and message types (Module 1)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simulation Concepts"}),": Understanding of Gazebo and Isaac simulation (Module 2-3)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Navigation Systems"}),": Understanding of Nav2 and path planning (Module 3, Chapter 3)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Machine Learning"}),": Basic understanding of transfer learning and domain adaptation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control Systems"}),": Basic understanding of robot dynamics and control"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"software-prerequisites",children:"Software Prerequisites"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Operating System"}),": Ubuntu 22.04 LTS with ROS 2 Humble Hawksbill"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Isaac Sim"}),": NVIDIA Isaac Sim for simulation environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Python"}),": Version 3.10 or higher"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Machine Learning Libraries"}),": PyTorch, TensorFlow for model training"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Calibration Tools"}),": Camera calibration, IMU calibration utilities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visualization Tools"}),": RViz2, Isaac Sim visualization"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Terminal"}),": Bash shell access"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"installation-verification",children:"Installation Verification"}),"\n",(0,a.jsx)(e.p,{children:"Verify your sim-to-real environment:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:'# Check Isaac Sim installation\nisaac-sim --version 2>/dev/null || echo "Isaac Sim may be available in launcher"\n\n# Check calibration tools\nros2 pkg list | grep -i calib\n\n# Check for machine learning packages\npython3 -c "import torch; import tensorflow; print(\'ML libraries available\')"\n\n# Check sensor packages\nros2 pkg list | grep sensor\n'})}),"\n",(0,a.jsx)(e.p,{children:"Expected output: Available calibration tools, ML libraries, and sensor packages."}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"In the previous chapters, we explored NVIDIA Isaac for simulation, Visual SLAM for mapping, and Nav2 for navigation. Now we'll focus on one of the most critical challenges in robotics: sim-to-real transfer. The reality gap\u2014the difference between simulated and real environments\u2014can cause policies trained in simulation to fail when deployed on physical robots. This challenge has historically limited the effectiveness of simulation in robotics development."}),"\n",(0,a.jsx)(e.p,{children:"Think of sim-to-real transfer like training a pilot in a flight simulator: while simulators can provide valuable training, real-world conditions (wind, turbulence, mechanical differences) can cause performance gaps. In robotics, these differences manifest as variations in sensor noise, dynamics, lighting, materials, and environmental conditions that can make simulation-trained behaviors ineffective on real robots."}),"\n",(0,a.jsx)(e.p,{children:"In Physical AI systems, successful sim-to-real transfer is crucial for efficient development. Training policies in simulation can be orders of magnitude faster than real-world training, but only if the learned behaviors transfer effectively. Modern techniques like domain randomization, system identification, and progressive transfer have made sim-to-real transfer increasingly viable for complex robotics tasks."}),"\n",(0,a.jsx)(e.p,{children:"In this chapter, we'll explore the principles of sim-to-real transfer, implement domain randomization techniques, learn calibration methods, and understand how to evaluate and improve transfer performance. We'll focus on practical techniques that maximize the benefits of simulation while ensuring successful real-world deployment."}),"\n",(0,a.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,a.jsx)(e.h3,{id:"the-reality-gap-problem",children:"The Reality Gap Problem"}),"\n",(0,a.jsx)(e.p,{children:"The reality gap encompasses several types of differences between simulation and reality:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual Differences"}),": Lighting, textures, reflections, sensor noise"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physical Differences"}),": Dynamics, friction, contact models, motor characteristics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Differences"}),": Layout, objects, interactions, disturbances"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Temporal Differences"}),": Timing, latency, processing delays"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,a.jsx)(e.p,{children:"Domain randomization is a key technique for sim-to-real transfer:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual Randomization"}),": Randomizing colors, textures, lighting conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physical Randomization"}),": Varying friction, mass, inertia, dynamics parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Randomization"}),": Changing layouts, object positions, lighting"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Randomization"}),": Adding realistic noise models and imperfections"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"The principle is that by training on a wide variety of randomized conditions, policies become robust to the differences between simulation and reality."}),"\n",(0,a.jsx)(e.h3,{id:"system-identification",children:"System Identification"}),"\n",(0,a.jsx)(e.p,{children:"System identification involves calibrating simulation parameters to match real robot behavior:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamics Calibration"}),": Matching mass, inertia, friction parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Calibration"}),": Aligning sensor characteristics and noise models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuator Calibration"}),": Matching motor response and control characteristics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Calibration"}),": Measuring and modeling real-world conditions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"progressive-transfer",children:"Progressive Transfer"}),"\n",(0,a.jsx)(e.p,{children:"Progressive transfer gradually moves from simulation to reality:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pure Simulation"}),": Initial training in basic simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Enhanced Simulation"}),": Adding realistic elements and noise"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Mixed Reality"}),": Combining simulation and real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real World"}),": Deployment with minimal fine-tuning"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"transfer-learning-approaches",children:"Transfer Learning Approaches"}),"\n",(0,a.jsx)(e.p,{children:"Several approaches facilitate sim-to-real transfer:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Domain Adaptation"}),": Adapting models to new domains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Meta Learning"}),": Learning to learn across domains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Few-Shot Learning"}),": Adapting with minimal real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simulated Annealing"}),": Gradually increasing simulation realism"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-for-transfer",children:"Isaac Sim for Transfer"}),"\n",(0,a.jsx)(e.p,{children:"Isaac Sim provides several features for sim-to-real transfer:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Domain Randomization"}),": Built-in randomization tools"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Realistic Physics"}),": Accurate PhysX simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Models"}),": Realistic camera, LiDAR, IMU models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Calibration Tools"}),": System identification and parameter tuning"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(e.p,{children:"Let's implement sim-to-real transfer techniques with Isaac Sim:"}),"\n",(0,a.jsx)(e.h3,{id:"domain-randomization-script-for-isaac-sim-domain_randomizationpy",children:"Domain Randomization Script for Isaac Sim (domain_randomization.py)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import omni\nfrom pxr import Gf, UsdGeom\nimport carb\nimport numpy as np\nimport random\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import get_prim_at_path\nfrom omni.isaac.core.utils.stage import get_stage_units\n\n\nclass DomainRandomizer:\n    \"\"\"\n    Class to implement domain randomization in Isaac Sim.\n    Randomizes visual, physical, and environmental parameters.\n    \"\"\"\n\n    def __init__(self, world):\n        self.world = world\n        self.randomization_params = {\n            # Visual randomization parameters\n            'light_intensity_range': (0.5, 2.0),\n            'light_color_range': (0.8, 1.2),\n            'material_roughness_range': (0.1, 0.9),\n            'material_metallic_range': (0.0, 0.5),\n\n            # Physical randomization parameters\n            'friction_range': (0.1, 1.0),\n            'restitution_range': (0.0, 0.5),\n            'mass_multiplier_range': (0.8, 1.2),\n\n            # Environmental randomization parameters\n            'object_position_jitter': 0.1,\n            'object_rotation_jitter': 0.1,\n        }\n\n        self.stage = omni.usd.get_context().get_stage()\n\n    def randomize_lights(self):\n        \"\"\"Randomize lighting conditions in the scene.\"\"\"\n        # Get all light prims in the stage\n        light_prims = []\n        for prim in self.stage.TraverseAll():\n            if prim.GetTypeName() in ['DistantLight', 'SphereLight', 'RectLight']:\n                light_prims.append(prim)\n\n        for light_prim in light_prims:\n            # Randomize light intensity\n            intensity_range = self.randomization_params['light_intensity_range']\n            new_intensity = random.uniform(*intensity_range)\n\n            # Set the intensity\n            light_prim.GetAttribute('inputs:intensity').Set(new_intensity)\n\n            # Randomize light color (simplified)\n            color_range = self.randomization_params['light_color_range']\n            r = random.uniform(*color_range)\n            g = random.uniform(*color_range)\n            b = random.uniform(*color_range)\n\n            light_prim.GetAttribute('inputs:color').Set(Gf.Vec3f(r, g, b))\n\n    def randomize_materials(self):\n        \"\"\"Randomize material properties in the scene.\"\"\"\n        # Get all material prims\n        material_prims = []\n        for prim in self.stage.TraverseAll():\n            if 'Material' in prim.GetTypeName():\n                material_prims.append(prim)\n\n        for material_prim in material_prims:\n            # Randomize roughness\n            roughness_range = self.randomization_params['material_roughness_range']\n            new_roughness = random.uniform(*roughness_range)\n\n            # Find and set roughness parameter if it exists\n            roughness_attr = material_prim.GetAttribute('inputs:roughness')\n            if roughness_attr:\n                roughness_attr.Set(new_roughness)\n\n            # Randomize metallic\n            metallic_range = self.randomization_params['material_metallic_range']\n            new_metallic = random.uniform(*metallic_range)\n\n            metallic_attr = material_prim.GetAttribute('inputs:metallic')\n            if metallic_attr:\n                metallic_attr.Set(new_metallic)\n\n    def randomize_physics(self):\n        \"\"\"Randomize physical properties of objects.\"\"\"\n        # Get all rigid bodies in the scene\n        rigid_body_prims = []\n        for prim in self.stage.TraverseAll():\n            if prim.HasAttribute('physics:friction'):\n                rigid_body_prims.append(prim)\n\n        for body_prim in rigid_body_prims:\n            # Randomize friction\n            friction_range = self.randomization_params['friction_range']\n            new_friction = random.uniform(*friction_range)\n\n            friction_attr = body_prim.GetAttribute('physics:friction')\n            if friction_attr:\n                friction_attr.Set(new_friction)\n\n            # Randomize restitution (bounciness)\n            restitution_range = self.randomization_params['restitution_range']\n            new_restitution = random.uniform(*restitution_range)\n\n            restitution_attr = body_prim.GetAttribute('physics:restitution')\n            if restitution_attr:\n                restitution_attr.Set(new_restitution)\n\n    def randomize_environment(self):\n        \"\"\"Randomize environmental elements.\"\"\"\n        # Get all object prims that can be moved\n        object_prims = []\n        for prim in self.stage.TraverseAll():\n            if prim.HasAttribute('xformOp:translate') and 'ground' not in prim.GetName().lower():\n                object_prims.append(prim)\n\n        for obj_prim in object_prims:\n            # Get current position\n            current_pos_attr = obj_prim.GetAttribute('xformOp:translate')\n            if current_pos_attr:\n                current_pos = current_pos_attr.Get()\n\n                # Add random jitter\n                jitter = self.randomization_params['object_position_jitter']\n                new_x = current_pos[0] + random.uniform(-jitter, jitter)\n                new_y = current_pos[1] + random.uniform(-jitter, jitter)\n                new_z = current_pos[2] + random.uniform(-jitter, jitter)\n\n                # Set new position\n                current_pos_attr.Set(Gf.Vec3d(new_x, new_y, new_z))\n\n    def apply_randomization(self):\n        \"\"\"Apply all randomization techniques.\"\"\"\n        self.randomize_lights()\n        self.randomize_materials()\n        self.randomize_physics()\n        self.randomize_environment()\n\n        print(f\"Applied domain randomization with {len(self.stage.GetPrimAtPath('/World').GetChildren())} objects\")\n\n\nclass SimToRealTransferNode:\n    \"\"\"\n    Node that demonstrates sim-to-real transfer techniques.\n    Includes calibration and evaluation methods.\n    \"\"\"\n\n    def __init__(self):\n        # Simulation parameters that need calibration\n        self.sim_params = {\n            'robot_mass': 10.0,  # kg\n            'wheel_radius': 0.1,  # m\n            'wheel_base': 0.5,   # m\n            'motor_torque_limit': 5.0,  # Nm\n            'friction_coefficient': 0.8,\n        }\n\n        # Real robot parameters (initially unknown, to be calibrated)\n        self.real_params = {\n            'robot_mass': None,\n            'wheel_radius': None,\n            'wheel_base': None,\n            'motor_torque_limit': None,\n            'friction_coefficient': None,\n        }\n\n        # Calibration data\n        self.calibration_data = []\n\n        print(\"Sim-to-real transfer node initialized\")\n\n    def collect_calibration_data(self, sim_behavior, real_behavior):\n        \"\"\"Collect data pairs of simulation vs. real behavior for calibration.\"\"\"\n        calibration_pair = {\n            'sim': sim_behavior,\n            'real': real_behavior,\n            'timestamp': time.time()\n        }\n        self.calibration_data.append(calibration_pair)\n\n        print(f\"Collected calibration data point #{len(self.calibration_data)}\")\n\n    def calibrate_simulation(self):\n        \"\"\"Calibrate simulation parameters based on collected data.\"\"\"\n        if len(self.calibration_data) < 10:\n            print(\"Need more calibration data (at least 10 points)\")\n            return False\n\n        # Simple calibration algorithm (in practice, more sophisticated methods are used)\n        # This is a simplified example - real calibration involves system identification\n\n        # Example: adjust friction coefficient based on velocity differences\n        velocity_errors = []\n        for data_pair in self.calibration_data:\n            sim_vel = data_pair['sim'].get('linear_velocity', 0)\n            real_vel = data_pair['real'].get('linear_velocity', 0)\n            error = real_vel - sim_vel\n            velocity_errors.append(error)\n\n        avg_error = sum(velocity_errors) / len(velocity_errors)\n\n        # Adjust friction based on velocity error (simplified model)\n        if abs(avg_error) > 0.1:  # If error is significant\n            adjustment_factor = 1.0 + avg_error * 0.1  # Simple proportional adjustment\n            self.sim_params['friction_coefficient'] *= adjustment_factor\n            print(f\"Adjusted friction coefficient to {self.sim_params['friction_coefficient']:.3f}\")\n\n        return True\n\n    def evaluate_transfer_performance(self, policy, test_episodes=10):\n        \"\"\"Evaluate how well a policy transfers from sim to real.\"\"\"\n        sim_successes = 0\n        real_successes = 0\n\n        for episode in range(test_episodes):\n            # Test in simulation\n            sim_result = self.test_policy_in_simulation(policy)\n            if sim_result['success']:\n                sim_successes += 1\n\n            # Test on real robot (in practice, this would connect to actual hardware)\n            real_result = self.test_policy_in_real_world(policy)\n            if real_result['success']:\n                real_successes += 1\n\n        sim_success_rate = sim_successes / test_episodes\n        real_success_rate = real_successes / test_episodes\n        transfer_gap = sim_success_rate - real_success_rate\n\n        performance_metrics = {\n            'sim_success_rate': sim_success_rate,\n            'real_success_rate': real_success_rate,\n            'transfer_gap': transfer_gap,\n            'transfer_efficiency': real_success_rate / max(sim_success_rate, 0.001)\n        }\n\n        print(f\"Transfer Performance: Sim={sim_success_rate:.2f}, Real={real_success_rate:.2f}, Gap={transfer_gap:.2f}\")\n        return performance_metrics\n\n    def test_policy_in_simulation(self, policy):\n        \"\"\"Test policy in simulation environment.\"\"\"\n        # In a real implementation, this would run the policy in Isaac Sim\n        # For this example, we'll simulate the result\n        import random\n        success = random.random() > 0.2  # 80% success rate in simulation\n        return {'success': success, 'time': random.uniform(10, 30)}\n\n    def test_policy_in_real_world(self, policy):\n        \"\"\"Test policy on real robot (simulation of real world).\"\"\"\n        # In a real implementation, this would connect to actual robot hardware\n        # For this example, we'll simulate a lower success rate to represent reality gap\n        import random\n        success = random.random() > 0.5  # 50% success rate in real world (lower due to reality gap)\n        return {'success': success, 'time': random.uniform(15, 35)}\n\n\ndef main():\n    \"\"\"Main function demonstrating sim-to-real transfer techniques.\"\"\"\n    print(\"Initializing sim-to-real transfer demonstration...\")\n\n    # In Isaac Sim, you would initialize the world\n    # world = World(stage_units_in_meters=1.0)\n\n    # Create domain randomizer\n    # randomizer = DomainRandomizer(world)\n\n    # Apply randomization\n    # randomizer.apply_randomization()\n\n    # Create transfer node\n    transfer_node = SimToRealTransferNode()\n\n    # Example of calibration process\n    print(\"\\n--- Calibrating Simulation ---\")\n    # In practice, you would collect real data and calibrate\n    # transfer_node.calibrate_simulation()\n\n    # Example of transfer evaluation\n    print(\"\\n--- Evaluating Transfer Performance ---\")\n    dummy_policy = {'type': 'navigation', 'parameters': {}}\n    performance = transfer_node.evaluate_transfer_performance(dummy_policy, test_episodes=5)\n\n    print(f\"\\nTransfer Efficiency: {performance['transfer_efficiency']:.2f}\")\n    print(\"Sim-to-real transfer demonstration completed!\")\n\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-randomization-extension-randomization_extensionpy",children:"Isaac Sim Randomization Extension (randomization_extension.py)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import omni\nfrom pxr import Gf, Sdf, UsdGeom\nimport carb\nimport numpy as np\nimport random\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import get_prim_at_path, define_prim\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\n\n\nclass RandomizationExtension:\n    """\n    Isaac Sim extension for domain randomization.\n    Provides GUI controls and automated randomization.\n    """\n\n    def __init__(self):\n        self.world = None\n        self.randomizer = None\n        self.enabled = False\n        self.randomization_frequency = 100  # randomize every 100 steps\n        self.step_count = 0\n\n        print("Randomization extension initialized")\n\n    def setup_randomization(self, world):\n        """Setup randomization for the Isaac Sim world."""\n        self.world = world\n        self.randomizer = DomainRandomizer(world)\n        print("Randomization setup completed")\n\n    def on_step(self, step_size):\n        """Called on each simulation step."""\n        self.step_count += 1\n\n        if self.enabled and self.step_count % self.randomization_frequency == 0:\n            self.randomizer.apply_randomization()\n            print(f"Applied randomization at step {self.step_count}")\n\n    def enable_randomization(self):\n        """Enable domain randomization."""\n        self.enabled = True\n        print("Domain randomization enabled")\n\n    def disable_randomization(self):\n        """Disable domain randomization."""\n        self.enabled = False\n        print("Domain randomization disabled")\n\n    def set_randomization_frequency(self, frequency):\n        """Set how often randomization is applied."""\n        self.randomization_frequency = frequency\n        print(f"Randomization frequency set to {frequency} steps")\n\n    def get_randomization_stats(self):\n        """Get statistics about randomization."""\n        stats = {\n            \'enabled\': self.enabled,\n            \'frequency\': self.randomization_frequency,\n            \'steps_since_randomization\': self.step_count % self.randomization_frequency,\n            \'total_steps\': self.step_count\n        }\n        return stats\n\n\n# Example of Isaac Sim configuration for domain randomization\nISAAC_DOMAIN_RANDOMIZATION_CONFIG = {\n    "domain_randomization": {\n        "enabled": True,\n        "frequency": 100,\n        "visual_randomization": {\n            "lighting": {\n                "enabled": True,\n                "intensity_range": [0.5, 2.0],\n                "color_temperature_range": [5000, 8000]\n            },\n            "materials": {\n                "enabled": True,\n                "roughness_range": [0.1, 0.9],\n                "metallic_range": [0.0, 0.5],\n                "albedo_range": [0.1, 1.0]\n            },\n            "textures": {\n                "enabled": True,\n                "random_texture_probability": 0.3\n            }\n        },\n        "physical_randomization": {\n            "dynamics": {\n                "enabled": True,\n                "mass_multiplier_range": [0.8, 1.2],\n                "friction_range": [0.1, 1.0],\n                "restitution_range": [0.0, 0.5]\n            },\n            "actuators": {\n                "enabled": True,\n                "torque_noise_std": 0.05,\n                "position_noise_std": 0.01\n            }\n        },\n        "sensor_randomization": {\n            "camera": {\n                "enabled": True,\n                "noise_std": 0.01,\n                "distortion_range": [0.0, 0.1]\n            },\n            "lidar": {\n                "enabled": True,\n                "noise_std": 0.02,\n                "dropout_rate": 0.01\n            }\n        }\n    }\n}\n\n\ndef apply_calibration_to_robot(robot_config, calibration_data):\n    """\n    Apply calibration data to robot configuration.\n    This function would typically update robot URDF/SDF with calibrated parameters.\n    """\n    calibrated_config = robot_config.copy()\n\n    # Apply calibration adjustments\n    for param_name, adjustment in calibration_data.items():\n        if param_name in calibrated_config:\n            calibrated_config[param_name] *= (1.0 + adjustment.get(\'multiplier\', 0))\n            calibrated_config[param_name] += adjustment.get(\'offset\', 0)\n\n    return calibrated_config\n\n\ndef create_calibration_routine():\n    """\n    Create a calibration routine for aligning simulation and reality.\n    This would typically involve collecting data and running system identification.\n    """\n    calibration_steps = [\n        "Collect open-loop trajectory data",\n        "Identify dynamic parameters",\n        "Calibrate sensor models",\n        "Validate calibration on held-out data",\n        "Deploy calibrated model to simulation"\n    ]\n\n    print("Calibration routine steps:")\n    for i, step in enumerate(calibration_steps, 1):\n        print(f"  {i}. {step}")\n\n    return calibration_steps\n\n\ndef main():\n    """Main function for sim-to-real transfer demonstration."""\n    print("=== Isaac Sim Domain Randomization and Calibration ===\\n")\n\n    # Show configuration\n    print("Domain Randomization Configuration:")\n    import json\n    print(json.dumps(ISAAC_DOMAIN_RANDOMIZATION_CONFIG, indent=2))\n\n    print("\\nCalibration Routine:")\n    create_calibration_routine()\n\n    print("\\nSim-to-real transfer setup complete!")\n    print("Next steps: Implement in Isaac Sim extension and test with real robot.")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,a.jsx)(e.h3,{id:"transfer-evaluation-script-transfer_evaluationpy",children:"Transfer Evaluation Script (transfer_evaluation.py)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float32, Bool\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Odometry\nimport numpy as np\nimport time\nimport pickle\nfrom collections import deque\n\n\nclass TransferEvaluator(Node):\n    \"\"\"\n    Node to evaluate sim-to-real transfer performance.\n    Compares behavior between simulation and reality.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('transfer_evaluator')\n\n        # Performance tracking\n        self.sim_performance = deque(maxlen=100)\n        self.real_performance = deque(maxlen=100)\n        self.transfer_gap_history = deque(maxlen=100)\n\n        # Metrics\n        self.total_episodes = 0\n        self.sim_successes = 0\n        self.real_successes = 0\n\n        # Publishers and subscribers\n        self.transfer_gap_pub = self.create_publisher(Float32, '/transfer_gap', 10)\n        self.performance_pub = self.create_publisher(Float32, '/transfer_performance', 10)\n\n        # Timer for evaluation\n        self.eval_timer = self.create_timer(5.0, self.evaluate_transfer)\n\n        self.get_logger().info('Transfer evaluator initialized')\n\n    def evaluate_transfer(self):\n        \"\"\"Evaluate and publish transfer performance metrics.\"\"\"\n        if len(self.sim_performance) == 0 or len(self.real_performance) == 0:\n            return\n\n        # Calculate metrics\n        avg_sim_perf = np.mean(list(self.sim_performance))\n        avg_real_perf = np.mean(list(self.real_performance))\n        transfer_gap = avg_sim_perf - avg_real_perf\n        transfer_efficiency = avg_real_perf / max(avg_sim_perf, 0.001)\n\n        # Store history\n        self.transfer_gap_history.append(transfer_gap)\n\n        # Publish metrics\n        gap_msg = Float32()\n        gap_msg.data = float(transfer_gap)\n        self.transfer_gap_pub.publish(gap_msg)\n\n        perf_msg = Float32()\n        perf_msg.data = float(transfer_efficiency)\n        self.performance_pub.publish(perf_msg)\n\n        self.get_logger().info(\n            f'Transfer Metrics - Sim: {avg_sim_perf:.3f}, '\n            f'Real: {avg_real_perf:.3f}, Gap: {transfer_gap:.3f}, '\n            f'Efficiency: {transfer_efficiency:.3f}'\n        )\n\n    def record_episode_result(self, environment, success, performance_metric):\n        \"\"\"Record the result of an episode.\"\"\"\n        if environment == 'simulation':\n            self.sim_performance.append(performance_metric)\n            if success:\n                self.sim_successes += 1\n        elif environment == 'real':\n            self.real_performance.append(performance_metric)\n            if success:\n                self.real_successes += 1\n\n        self.total_episodes += 1\n\n        # Log progress\n        if self.total_episodes % 10 == 0:\n            sim_rate = self.sim_successes / max(len(self.sim_performance), 1)\n            real_rate = self.real_successes / max(len(self.real_performance), 1)\n            self.get_logger().info(\n                f'Progress: {self.total_episodes} episodes, '\n                f'Sim success: {sim_rate:.2f}, Real success: {real_rate:.2f}'\n            )\n\n    def calculate_transfer_improvement(self):\n        \"\"\"Calculate improvement in transfer over time.\"\"\"\n        if len(self.transfer_gap_history) < 10:\n            return 0.0\n\n        # Compare recent performance to early performance\n        recent_gap = np.mean(list(self.transfer_gap_history)[-10:])\n        early_gap = np.mean(list(self.transfer_gap_history)[:10])\n\n        improvement = early_gap - recent_gap  # Positive if gap is closing\n        return float(improvement)\n\n\ndef main(args=None):\n    \"\"\"Main function to run the transfer evaluator.\"\"\"\n    rclpy.init(args=args)\n\n    evaluator = TransferEvaluator()\n\n    try:\n        rclpy.spin(evaluator)\n    except KeyboardInterrupt:\n        evaluator.get_logger().info('Transfer evaluator shutting down...')\n\n        # Print final statistics\n        if evaluator.total_episodes > 0:\n            sim_rate = evaluator.sim_successes / max(len(evaluator.sim_performance), 1)\n            real_rate = evaluator.real_successes / max(len(evaluator.real_performance), 1)\n            final_gap = np.mean(list(evaluator.transfer_gap_history)) if evaluator.transfer_gap_history else 0\n\n            evaluator.get_logger().info(\n                f'Final Transfer Statistics:\\n'\n                f'  Total Episodes: {evaluator.total_episodes}\\n'\n                f'  Sim Success Rate: {sim_rate:.3f}\\n'\n                f'  Real Success Rate: {real_rate:.3f}\\n'\n                f'  Average Transfer Gap: {final_gap:.3f}\\n'\n                f'  Transfer Efficiency: {real_rate/max(sim_rate, 0.001):.3f}'\n            )\n\n    finally:\n        evaluator.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Expected Output:"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"[INFO] [transfer_evaluator]: Transfer evaluator initialized\n[INFO] [transfer_evaluator]: Progress: 10 episodes, Sim success: 0.85, Real success: 0.62\n[INFO] [transfer_evaluator]: Transfer Metrics - Sim: 0.845, Real: 0.612, Gap: 0.233, Efficiency: 0.724\n[INFO] [transfer_evaluator]: Transfer Metrics - Sim: 0.831, Real: 0.689, Gap: 0.142, Efficiency: 0.829\n[INFO] [transfer_evaluator]: Final Transfer Statistics:\n  Total Episodes: 50\n  Sim Success Rate: 0.821\n  Real Success Rate: 0.715\n  Average Transfer Gap: 0.106\n  Transfer Efficiency: 0.871\n[INFO] [transfer_evaluator]: Transfer evaluator shutting down...\n"})}),"\n",(0,a.jsx)(e.h3,{id:"running-the-example",children:"Running the Example"}),"\n",(0,a.jsx)(e.p,{children:"To run these sim-to-real transfer examples:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Terminal 1: Start Isaac Sim with domain randomization\n# Launch Isaac Sim through the Omniverse launcher\n# Enable the domain randomization extension\n\n# Terminal 2: Run the transfer evaluation node\nsource /opt/ros/humble/setup.bash\nros2 run isaac_transfer_examples transfer_evaluator\n\n# Terminal 3: Run robot control in simulation\nsource /opt/ros/humble/setup.bash\nros2 run isaac_transfer_examples robot_controller_sim\n\n# Terminal 4: Run robot control on real robot (when available)\nsource /opt/ros/humble/setup.bash\nros2 run isaac_transfer_examples robot_controller_real\n\n# Terminal 5: Monitor transfer metrics\nsource /opt/ros/humble/setup.bash\nros2 topic echo /transfer_gap\nros2 topic echo /transfer_performance\n\n# Terminal 6: Visualize in RViz2\nsource /opt/ros/humble/setup.bash\nrviz2\n# Add displays for transfer metrics and performance plots\n"})}),"\n",(0,a.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsx)(e.h3,{id:"exercise-1-domain-randomization-effectiveness",children:"Exercise 1: Domain Randomization Effectiveness"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Task"}),": Evaluate the effectiveness of different domain randomization strategies."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement multiple randomization strategies (visual, physical, sensor)"}),"\n",(0,a.jsx)(e.li,{children:"Train a simple policy under each strategy"}),"\n",(0,a.jsx)(e.li,{children:"Test transfer performance for each strategy"}),"\n",(0,a.jsx)(e.li,{children:"Compare results and identify most effective approaches"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Success Criteria"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Multiple randomization strategies implemented"}),"\n",(0,a.jsx)(e.li,{children:"Policies trained and tested for each approach"}),"\n",(0,a.jsx)(e.li,{children:"Performance metrics collected and compared"}),"\n",(0,a.jsx)(e.li,{children:"Effective strategies identified and documented"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"exercise-2-system-identification",children:"Exercise 2: System Identification"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Task"}),": Perform system identification to calibrate simulation parameters."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Collect real robot data for specific motions"}),"\n",(0,a.jsx)(e.li,{children:"Run same motions in simulation with varying parameters"}),"\n",(0,a.jsx)(e.li,{children:"Use optimization to find best-fitting simulation parameters"}),"\n",(0,a.jsx)(e.li,{children:"Validate calibrated simulation against new real data"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Success Criteria"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Real and simulated data collected systematically"}),"\n",(0,a.jsx)(e.li,{children:"Parameter optimization completed successfully"}),"\n",(0,a.jsx)(e.li,{children:"Simulation calibrated to match real behavior"}),"\n",(0,a.jsx)(e.li,{children:"Validation shows improved alignment"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"exercise-3-progressive-transfer",children:"Exercise 3: Progressive Transfer"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Task"}),": Implement progressive transfer from simulation to reality."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Create simulation environments with increasing realism"}),"\n",(0,a.jsx)(e.li,{children:"Train policy in each progressively more realistic environment"}),"\n",(0,a.jsx)(e.li,{children:"Test final policy on real robot"}),"\n",(0,a.jsx)(e.li,{children:"Compare with direct simulation-to-reality transfer"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Success Criteria"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Progressive simulation environments created"}),"\n",(0,a.jsx)(e.li,{children:"Policy successfully trained through progression"}),"\n",(0,a.jsx)(e.li,{children:"Real-world performance validated"}),"\n",(0,a.jsx)(e.li,{children:"Comparison shows benefits of progressive approach"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Sim-to-real transfer is essential for leveraging simulation's benefits while ensuring real-world performance. We've explored domain randomization techniques that make policies robust to reality gaps, calibration methods that align simulation and reality, and evaluation metrics that quantify transfer success. The combination of visual, physical, and environmental randomization with systematic calibration enables effective transfer of learned behaviors from simulation to real robots."}),"\n",(0,a.jsx)(e.p,{children:"We've implemented examples showing domain randomization in Isaac Sim, calibration routines for parameter alignment, and evaluation frameworks for measuring transfer performance. These techniques are crucial for developing robust robotics systems that can benefit from simulation's efficiency while operating successfully in the real world."}),"\n",(0,a.jsx)(e.p,{children:"Understanding sim-to-real transfer principles is crucial for Physical AI systems that must operate effectively in real environments. The techniques enable safe, efficient development in simulation while ensuring successful deployment on physical robots."}),"\n",(0,a.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(e.p,{children:"Now that you understand sim-to-real transfer principles, the next chapter explores domain randomization techniques in detail. You'll learn advanced methods for randomizing simulation environments to maximize transfer success and explore specific techniques for different types of robots and tasks."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Next Chapter"}),": Module 3, Chapter 5: Domain Randomization Techniques"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(m,{...n})}):m(n)}}}]);