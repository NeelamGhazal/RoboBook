"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1977],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},9317:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-ros2/chapter-4-rclpy-python-client","title":"rclpy Python Client Library","description":"Learning Objectives","source":"@site/docs/module-1-ros2/chapter-4-rclpy-python-client.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-4-rclpy-python-client","permalink":"/RoboBook/docs/module-1-ros2/chapter-4-rclpy-python-client","draft":false,"unlisted":false,"editUrl":"https://github.com/NeelamGhazal/RoboBook/tree/main/docs/module-1-ros2/chapter-4-rclpy-python-client.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"rclpy Python Client Library","sidebar_position":5},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3: Services & Clients","permalink":"/RoboBook/docs/module-1-ros2/chapter-3-services-clients"},"next":{"title":"Chapter 5: URDF Robot Description","permalink":"/RoboBook/docs/module-1-ros2/chapter-5-urdf-robot-description"}}');var i=r(4848),t=r(8453);const a={title:"rclpy Python Client Library",sidebar_position:5},l="rclpy Python Client Library",o={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Knowledge Prerequisites",id:"knowledge-prerequisites",level:3},{value:"Software Prerequisites",id:"software-prerequisites",level:3},{value:"Installation Verification",id:"installation-verification",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Theory",id:"theory",level:2},{value:"rclpy Architecture",id:"rclpy-architecture",level:3},{value:"Parameters System",id:"parameters-system",level:3},{value:"Quality of Service (QoS) Profiles",id:"quality-of-service-qos-profiles",level:3},{value:"Lifecycle Nodes",id:"lifecycle-nodes",level:3},{value:"Threading and Concurrency",id:"threading-and-concurrency",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Running the Example",id:"running-the-example",level:3},{value:"Parameter Configuration File",id:"parameter-configuration-file",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Parameter Validation",id:"exercise-1-parameter-validation",level:3},{value:"Exercise 2: QoS Experimentation",id:"exercise-2-qos-experimentation",level:3},{value:"Exercise 3: Lifecycle Node Implementation",id:"exercise-3-lifecycle-node-implementation",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rclpy-python-client-library",children:"rclpy Python Client Library"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Explain the rclpy library architecture and its role in ROS 2 Python development"}),"\n",(0,i.jsx)(n.li,{children:"Implement advanced node features using rclpy parameters, timers, and callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Configure Quality of Service (QoS) settings for robust communication"}),"\n",(0,i.jsx)(n.li,{children:"Utilize lifecycle nodes for complex robot state management"}),"\n",(0,i.jsx)(n.li,{children:"Apply rclpy best practices for Physical AI applications"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.h3,{id:"knowledge-prerequisites",children:"Knowledge Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ROS 2 Nodes"}),": Understanding of ROS 2 node structure and lifecycle (Chapter 1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topics & Publishers/Subscribers"}),": Understanding of pub/sub pattern (Chapter 2)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Services & Clients"}),": Understanding of request/response pattern (Chapter 3)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Python Programming"}),": Intermediate understanding of classes, methods, and imports"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physical AI Concepts"}),": Understanding of Physical AI fundamentals from Chapter 0 (intro.md)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"software-prerequisites",children:"Software Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Operating System"}),": Ubuntu 22.04 LTS with ROS 2 Humble Hawksbill installed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Python"}),": Version 3.10 or higher"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal"}),": Bash shell access"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"installation-verification",children:"Installation Verification"}),"\n",(0,i.jsx)(n.p,{children:"Verify your rclpy installation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"source /opt/ros/humble/setup.bash\npython3 -c \"import rclpy; print('rclpy version:', rclpy.__version__)\"\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expected output: rclpy version information."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"In the previous chapters, we explored the fundamental communication patterns in ROS 2: nodes (Chapter 1), topics (Chapter 2), and services (Chapter 3). We've been using the rclpy Python client library throughout, but we've only scratched the surface of its capabilities. The rclpy library is the Python binding for the ROS 2 Client Library (rcl), providing Python developers with access to all ROS 2 features."}),"\n",(0,i.jsx)(n.p,{children:"Think of rclpy as the bridge between Python and the ROS 2 middleware. Just as a translation service allows speakers of different languages to communicate effectively, rclpy translates Python code into ROS 2 operations, enabling Python-based nodes to participate fully in ROS 2 systems. This is particularly important for Physical AI systems, where Python's rich ecosystem of machine learning and computer vision libraries (NumPy, OpenCV, PyTorch, TensorFlow) can be seamlessly integrated with ROS 2's distributed architecture."}),"\n",(0,i.jsx)(n.p,{children:"In Physical AI applications, rclpy enables developers to leverage Python's strengths in data processing, machine learning, and rapid prototyping while maintaining the robust communication patterns that ROS 2 provides. Whether you're implementing computer vision algorithms, machine learning models, or complex control systems, rclpy provides the tools to integrate them into a ROS 2 ecosystem."}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, we'll dive deep into rclpy's advanced features, exploring parameters, Quality of Service settings, and lifecycle management that are essential for production-ready Physical AI systems."}),"\n",(0,i.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.h3,{id:"rclpy-architecture",children:"rclpy Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The rclpy library sits between Python applications and the ROS 2 middleware:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:'%%{title: "rclpy Architecture"}%%\ngraph TB\n    subgraph "Python Application"\n        A["Python Node"]\n        B["rclpy API"]\n    end\n\n    subgraph "ROS 2 Middleware"\n        C["rcl (ROS Client Library)"]\n        D["DDS (Data Distribution Service)"]\n    end\n\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n'})}),"\n",(0,i.jsx)(n.p,{children:"rclpy provides Pythonic interfaces to ROS 2 concepts while maintaining the performance and reliability of the underlying C-based ROS Client Library (rcl)."}),"\n",(0,i.jsx)(n.h3,{id:"parameters-system",children:"Parameters System"}),"\n",(0,i.jsx)(n.p,{children:"Parameters in ROS 2 provide a way to configure nodes at runtime without recompiling. The parameters system offers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic reconfiguration"}),": Parameters can be changed while nodes are running"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hierarchical organization"}),": Parameters can be organized in namespaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type safety"}),": Parameters have strict type definitions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Default values"}),": Parameters can have default values specified at declaration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation"}),": Parameter values can be validated before acceptance"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Parameters are crucial for Physical AI systems where operational parameters (sensor thresholds, control gains, safety limits) may need adjustment during deployment."}),"\n",(0,i.jsx)(n.h3,{id:"quality-of-service-qos-profiles",children:"Quality of Service (QoS) Profiles"}),"\n",(0,i.jsx)(n.p,{children:"QoS profiles control how messages are delivered in ROS 2 systems:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reliability"}),": Reliable (all messages delivered) vs Best Effort (some messages may be dropped)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Durability"}),": Transient Local (late-joining subscribers get last message) vs Volatile (no historical messages)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"History"}),": Keep All (store all messages) vs Keep Last (store only recent messages)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Depth"}),": Maximum number of messages to store when using Keep Last"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"QoS settings are essential for Physical AI systems where different data types have different requirements: sensor data might require reliable delivery while debug information can tolerate best-effort delivery."}),"\n",(0,i.jsx)(n.h3,{id:"lifecycle-nodes",children:"Lifecycle Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Lifecycle nodes provide a structured approach to node state management with well-defined transitions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unconfigured"}),": Node created but not configured"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inactive"}),": Node configured but not active"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Active"}),": Node running and processing data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Finalized"}),": Node cleaned up and ready for destruction"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This state machine approach is important for Physical AI systems that need to manage complex initialization sequences, safety states, and graceful shutdown procedures."}),"\n",(0,i.jsx)(n.h3,{id:"threading-and-concurrency",children:"Threading and Concurrency"}),"\n",(0,i.jsx)(n.p,{children:"rclpy handles threading and concurrency through:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single-threaded executor"}),": Processes callbacks sequentially"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-threaded executor"}),": Processes callbacks in parallel"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Callback groups"}),": Organize callbacks for execution control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mutual exclusion"}),": Prevent race conditions in node state"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Proper concurrency management is critical for Physical AI systems that must handle multiple sensor streams and control outputs simultaneously."}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.p,{children:"Let's implement a comprehensive example that demonstrates advanced rclpy features:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\nimport time\n\n\nclass AdvancedNode(Node):\n    \"\"\"\n    Advanced ROS 2 node demonstrating rclpy features:\n    - Parameters with validation\n    - Quality of Service settings\n    - Threading and callback groups\n    - Advanced publisher/subscriber patterns\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_node')\n\n        # 1. Parameters with validation\n        self.declare_parameter('robot_name', 'physical_ai_robot')\n        self.declare_parameter('max_velocity', 1.0)\n        self.declare_parameter('safety_distance', 0.5)\n        self.declare_parameter('sensor_timeout', 1.0)\n\n        # Access parameters\n        self.robot_name = self.get_parameter('robot_name').value\n        self.max_velocity = self.get_parameter('max_velocity').value\n        self.safety_distance = self.get_parameter('safety_distance').value\n        self.sensor_timeout = self.get_parameter('sensor_timeout').value\n\n        self.get_logger().info(f'Node initialized for robot: {self.robot_name}')\n\n        # 2. Create callback groups for threading control\n        self.sensor_callback_group = MutuallyExclusiveCallbackGroup()\n        self.control_callback_group = MutuallyExclusiveCallbackGroup()\n\n        # 3. Quality of Service profiles\n        sensor_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        control_qos = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # 4. Publishers with QoS settings\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            'cmd_vel',\n            control_qos\n        )\n\n        self.status_publisher = self.create_publisher(\n            String,\n            'status',\n            sensor_qos\n        )\n\n        # 5. Subscribers with QoS settings and callback groups\n        self.scan_subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.scan_callback,\n            sensor_qos,\n            callback_group=self.sensor_callback_group\n        )\n\n        # 6. Timers with different periods\n        self.status_timer = self.create_timer(\n            1.0,  # 1 second\n            self.status_timer_callback,\n            callback_group=self.control_callback_group\n        )\n\n        self.control_timer = self.create_timer(\n            0.1,  # 100ms - more frequent for control\n            self.control_timer_callback,\n            callback_group=self.control_callback_group\n        )\n\n        # 7. Node state variables\n        self.latest_scan = None\n        self.safety_mode = False\n        self.last_scan_time = time.time()\n\n        self.get_logger().info('Advanced node initialized with all features')\n\n    def scan_callback(self, msg):\n        \"\"\"Callback for laser scan messages with safety checks.\"\"\"\n        self.latest_scan = msg\n        self.last_scan_time = time.time()\n\n        # Check for obstacles\n        if self.has_obstacle_ahead(msg):\n            self.safety_mode = True\n            self.get_logger().warn('Obstacle detected! Entering safety mode.')\n        else:\n            self.safety_mode = False\n\n    def has_obstacle_ahead(self, scan_msg):\n        \"\"\"Check if there's an obstacle in the forward direction.\"\"\"\n        # Check the middle portion of the scan (forward direction)\n        num_readings = len(scan_msg.ranges)\n        forward_start = num_readings // 2 - num_readings // 10\n        forward_end = num_readings // 2 + num_readings // 10\n\n        for i in range(forward_start, forward_end):\n            if 0 < scan_msg.ranges[i] < self.safety_distance:\n                return True\n        return False\n\n    def status_timer_callback(self):\n        \"\"\"Periodic status update.\"\"\"\n        status_msg = String()\n        status_msg.data = (\n            f'Robot: {self.robot_name}, Safety: {self.safety_mode}, Time: {time.time()}'\n        )\n        self.status_publisher.publish(status_msg)\n\n    def control_timer_callback(self):\n        \"\"\"Periodic control loop.\"\"\"\n        # Check sensor timeout\n        if time.time() - self.last_scan_time > self.sensor_timeout:\n            self.get_logger().error('Sensor timeout! Stopping robot.')\n            self.stop_robot()\n            return\n\n        # Generate control command based on safety state\n        cmd = Twist()\n        if self.safety_mode:\n            # Stop the robot if obstacle detected\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.0\n        else:\n            # Move forward at safe speed\n            cmd.linear.x = min(self.max_velocity, 0.5)\n            cmd.angular.z = 0.0\n\n        self.cmd_vel_publisher.publish(cmd)\n\n    def stop_robot(self):\n        \"\"\"Emergency stop function.\"\"\"\n        cmd = Twist()\n        cmd.linear.x = 0.0\n        cmd.angular.z = 0.0\n        self.cmd_vel_publisher.publish(cmd)\n\n\ndef main(args=None):\n    \"\"\"Main function with multi-threaded executor.\"\"\"\n    rclpy.init(args=args)\n\n    # Create the advanced node\n    advanced_node = AdvancedNode()\n\n    # Use multi-threaded executor to handle callbacks in parallel\n    executor = MultiThreadedExecutor(num_threads=4)\n    executor.add_node(advanced_node)\n\n    try:\n        # Spin with the multi-threaded executor\n        advanced_node.get_logger().info(\n            'Starting advanced node with multi-threaded executor...'\n        )\n        executor.spin()\n    except KeyboardInterrupt:\n        advanced_node.get_logger().info('Interrupt received, shutting down...')\n    finally:\n        # Cleanup\n        advanced_node.destroy_node()\n        rclpy.shutdown()\n        executor.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected Output:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[INFO] [advanced_node]: Node initialized for robot: physical_ai_robot\n[INFO] [advanced_node]: Advanced node initialized with all features\n[INFO] [advanced_node]: Starting advanced node with multi-threaded executor...\n[WARN] [advanced_node]: Obstacle detected! Entering safety mode.\n[INFO] [advanced_node]: Robot: physical_ai_robot, Safety: False, Time: 1234567890.123\n^C[INFO] [advanced_node]: Interrupt received, shutting down...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"running-the-example",children:"Running the Example"}),"\n",(0,i.jsxs)(n.p,{children:["To run this example, save it as ",(0,i.jsx)(n.code,{children:"advanced_node.py"})," and execute:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Source ROS 2 setup\nsource /opt/ros/humble/setup.bash\n\n# Run with custom parameters\npython3 advanced_node.py --ros-args -p robot_name:=my_robot -p max_velocity:=0.8\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameter-configuration-file",children:"Parameter Configuration File"}),"\n",(0,i.jsx)(n.p,{children:"You can also create a YAML configuration file to set parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# config/advanced_node_params.yaml\nadvanced_node:\n  ros__parameters:\n    robot_name: 'configured_robot'\n    max_velocity: 0.75\n    safety_distance: 0.6\n    sensor_timeout: 1.5\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then run with the configuration file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run my_package advanced_node --ros-args --params-file config/advanced_node_params.yaml\n"})}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-parameter-validation",children:"Exercise 1: Parameter Validation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task"}),": Add parameter validation to the advanced node."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement custom parameter validation callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Validate that max_velocity is within safe limits (e.g., 0.0 to 2.0 m/s)"}),"\n",(0,i.jsx)(n.li,{children:"Validate that safety_distance is positive"}),"\n",(0,i.jsx)(n.li,{children:"Test parameter changes at runtime using ros2 param commands"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success Criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Parameter validation prevents invalid values"}),"\n",(0,i.jsx)(n.li,{children:"Node continues operating with valid parameters"}),"\n",(0,i.jsx)(n.li,{children:"Validation errors are properly logged"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-qos-experimentation",children:"Exercise 2: QoS Experimentation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task"}),": Experiment with different Quality of Service profiles."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create publishers with different QoS settings"}),"\n",(0,i.jsx)(n.li,{children:"Test behavior under network stress"}),"\n",(0,i.jsx)(n.li,{children:"Observe how reliability and durability affect message delivery"}),"\n",(0,i.jsx)(n.li,{children:"Document when to use different QoS profiles"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success Criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Different QoS profiles are properly configured"}),"\n",(0,i.jsx)(n.li,{children:"Behavior changes as expected under different conditions"}),"\n",(0,i.jsx)(n.li,{children:"Understanding of QoS impact on system performance"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-3-lifecycle-node-implementation",children:"Exercise 3: Lifecycle Node Implementation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task"}),": Convert the advanced node to use the lifecycle node pattern."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Inherit from LifecycleNode instead of Node"}),"\n",(0,i.jsx)(n.li,{children:"Implement the required lifecycle callbacks (on_configure, on_activate, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"Test the state transitions"}),"\n",(0,i.jsx)(n.li,{children:"Compare with the regular node implementation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success Criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Lifecycle node properly implements state transitions"}),"\n",(0,i.jsx)(n.li,{children:"Node behaves correctly in each state"}),"\n",(0,i.jsx)(n.li,{children:"State changes are properly logged and managed"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"The rclpy Python client library provides comprehensive access to ROS 2 features, enabling Python developers to build sophisticated Physical AI systems. We've explored advanced features including parameters for runtime configuration, Quality of Service settings for robust communication, callback groups for threading control, and multi-threaded execution for concurrent processing."}),"\n",(0,i.jsx)(n.p,{children:"Parameters enable runtime configuration of Physical AI systems without code changes, while QoS profiles ensure appropriate handling of different data types. The threading and callback group system allows for efficient processing of multiple data streams simultaneously, which is essential for real-time Physical AI applications."}),"\n",(0,i.jsx)(n.p,{children:"Understanding rclpy's advanced features is crucial for building production-ready Physical AI systems that can handle the complexity and real-time requirements of physical robotics applications."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand the core ROS 2 concepts and the rclpy library, the next chapter explores URDF (Unified Robot Description Format), which is essential for describing robot geometry and kinematics. You'll learn how to define robot models that ROS 2 systems can use for simulation, visualization, and control."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next Chapter"}),": ",(0,i.jsx)(n.a,{href:"/docs/module-1-ros2/chapter-5-urdf-robot-description",children:"Module 1, Chapter 5: URDF Robot Description"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);