"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3570],{8453:(n,e,a)=>{a.d(e,{R:()=>o,x:()=>r});var i=a(6540);const t={},s=i.createContext(t);function o(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),i.createElement(s.Provider,{value:e},n.children)}},9210:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-3-isaac/chapter-3-nav2-navigation","title":"Nav2 Navigation Stack","description":"Learning Objectives","source":"@site/docs/module-3-isaac/chapter-3-nav2-navigation.md","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/chapter-3-nav2-navigation","permalink":"/RoboBook/docs/module-3-isaac/chapter-3-nav2-navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/NeelamGhazal/RoboBook/tree/main/docs/module-3-isaac/chapter-3-nav2-navigation.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"title":"Nav2 Navigation Stack","sidebar_position":14},"sidebar":"textbookSidebar","previous":{"title":"Chapter 2: Visual SLAM Mapping","permalink":"/RoboBook/docs/module-3-isaac/chapter-2-vslam-mapping"},"next":{"title":"Chapter 4: Sim-to-Real Transfer","permalink":"/RoboBook/docs/module-3-isaac/chapter-4-sim-to-real-principles"}}');var t=a(4848),s=a(8453);const o={title:"Nav2 Navigation Stack",sidebar_position:14},r="Nav2 Navigation Stack",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Knowledge Prerequisites",id:"knowledge-prerequisites",level:3},{value:"Software Prerequisites",id:"software-prerequisites",level:3},{value:"Installation Verification",id:"installation-verification",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Theory",id:"theory",level:2},{value:"Nav2 Architecture Overview",id:"nav2-architecture-overview",level:3},{value:"Core Nav2 Components",id:"core-nav2-components",level:3},{value:"Costmap System",id:"costmap-system",level:3},{value:"Behavior Trees in Nav2",id:"behavior-trees-in-nav2",level:3},{value:"Navigation Algorithms",id:"navigation-algorithms",level:3},{value:"Isaac Sim Integration",id:"isaac-sim-integration",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Nav2 Configuration (nav2_config.yaml)",id:"nav2-configuration-nav2_configyaml",level:3},{value:"Nav2 Client Node for Isaac Sim (nav2_client.py)",id:"nav2-client-node-for-isaac-sim-nav2_clientpy",level:3},{value:"Isaac Sim Integration Node (isaac_nav_integration.py)",id:"isaac-sim-integration-node-isaac_nav_integrationpy",level:3},{value:"Launch File for Nav2 Isaac Integration (nav2_isaac_launch.py)",id:"launch-file-for-nav2-isaac-integration-nav2_isaac_launchpy",level:3},{value:"Running the Example",id:"running-the-example",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Navigation Parameter Tuning",id:"exercise-1-navigation-parameter-tuning",level:3},{value:"Exercise 2: Behavior Tree Customization",id:"exercise-2-behavior-tree-customization",level:3},{value:"Exercise 3: Isaac Sim Navigation Testing",id:"exercise-3-isaac-sim-navigation-testing",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"nav2-navigation-stack",children:"Nav2 Navigation Stack"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Explain the Nav2 architecture and its components for autonomous navigation"}),"\n",(0,t.jsx)(e.li,{children:"Configure Nav2 for different robot platforms and environments"}),"\n",(0,t.jsx)(e.li,{children:"Implement navigation behaviors using Nav2's behavior tree system"}),"\n",(0,t.jsx)(e.li,{children:"Integrate Nav2 with Isaac Sim for simulation and testing"}),"\n",(0,t.jsx)(e.li,{children:"Evaluate and tune navigation performance metrics"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(e.h3,{id:"knowledge-prerequisites",children:"Knowledge Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2 Fundamentals"}),": Understanding of nodes, topics, and message types (Module 1)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simulation Concepts"}),": Understanding of Gazebo and Isaac simulation (Module 2-3)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"SLAM Concepts"}),": Understanding of mapping and localization (Module 3, Chapter 2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Control Systems"}),": Basic understanding of robot control and path following"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Behavior Trees"}),": Basic understanding of task planning and execution"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"software-prerequisites",children:"Software Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Operating System"}),": Ubuntu 22.04 LTS with ROS 2 Humble Hawksbill"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Nav2 Packages"}),": Navigation2 packages installed and configured"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Isaac Sim"}),": NVIDIA Isaac Sim for navigation testing (optional)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Python"}),": Version 3.10 or higher"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Visualization Tools"}),": RViz2 for navigation visualization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Map Tools"}),": Navigation map creation and editing tools"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terminal"}),": Bash shell access"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"installation-verification",children:"Installation Verification"}),"\n",(0,t.jsx)(e.p,{children:"Verify your Nav2 environment:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'# Check Nav2 packages\nros2 pkg list | grep nav2\n\n# Check Nav2 launch files\nfind /opt/ros/humble/share/ -name "*nav2*" -type d\n\n# Verify Nav2 services\nros2 service list | grep nav\n\n# Check Nav2 action servers\nros2 action list | grep navigate\n'})}),"\n",(0,t.jsx)(e.p,{children:"Expected output: Available Nav2 packages, services, and action servers."}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"In the previous chapters, we explored NVIDIA Isaac and Visual SLAM for mapping and localization. Now we'll focus on Nav2 (Navigation2), the state-of-the-art navigation stack for ROS 2 that enables autonomous robot navigation. Nav2 provides a complete framework for path planning, obstacle avoidance, and goal-directed navigation that works seamlessly with the maps created by SLAM systems."}),"\n",(0,t.jsx)(e.p,{children:'Think of Nav2 as a robot\'s "navigation brain" - just as humans use mental maps and planning to navigate from one location to another, Nav2 enables robots to plan safe paths, avoid obstacles, and reach goals autonomously. The system integrates perception, planning, and control to create robust navigation capabilities that work in dynamic environments.'}),"\n",(0,t.jsx)(e.p,{children:"In Physical AI systems, autonomous navigation is fundamental for mobile robots that need to operate independently. Nav2 provides the infrastructure for robots to move safely through environments, avoid both static and dynamic obstacles, and reach specified destinations. The stack is highly configurable and extensible, allowing it to work with different robot platforms and application requirements."}),"\n",(0,t.jsx)(e.p,{children:"In this chapter, we'll explore how to configure Nav2 for different scenarios, implement navigation behaviors using behavior trees, integrate with Isaac Sim for testing, and tune navigation performance for optimal results."}),"\n",(0,t.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,t.jsx)(e.h3,{id:"nav2-architecture-overview",children:"Nav2 Architecture Overview"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 is built around a flexible, modular architecture:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:'%%{title: "Nav2 Architecture"}%%\ngraph TB\n    subgraph "Navigation System"\n        A[Navigation Server] --\x3e B[Behavior Tree Engine]\n        B --\x3e C[Planner Server]\n        B --\x3e D[Controller Server]\n        B --\x3e E[Recovery Server]\n    end\n\n    subgraph "Sensors & Perception"\n        F[Costmap 2D] --\x3e G[Local Costmap]\n        F --\x3e H[Global Costmap]\n        I[SLAM Map] --\x3e H\n        J[Sensor Data] --\x3e F\n    end\n\n    subgraph "Execution"\n        K[Robot Controller] --\x3e L[Robot Driver]\n        M[Path Following] --\x3e K\n    end\n\n    C --\x3e H\n    D --\x3e G\n    G --\x3e M\n    H --\x3e C\n    G --\x3e D\n'})}),"\n",(0,t.jsx)(e.h3,{id:"core-nav2-components",children:"Core Nav2 Components"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Navigation Server"}),": Main orchestrator that manages the navigation lifecycle"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Planner Server"}),": Global path planner (A*, Dijkstra, etc.)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Controller Server"}),": Local path follower and obstacle avoidance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recovery Server"}),": Behavior for getting unstuck or recovering from failures"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Behavior Tree Engine"}),": Task orchestration using behavior trees"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"costmap-system",children:"Costmap System"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 uses two costmaps for navigation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Global Costmap"}),": Static map of the environment with static obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Local Costmap"}),": Dynamic map of immediate surroundings with real-time obstacles"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Costmaps represent the environment as a 2D grid where each cell contains a cost value:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"0: Free space"}),"\n",(0,t.jsx)(e.li,{children:"255: Obstacle"}),"\n",(0,t.jsx)(e.li,{children:"1-254: Increasing cost (inflation, navigation preferences)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"behavior-trees-in-nav2",children:"Behavior Trees in Nav2"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 uses behavior trees for navigation orchestration:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sequence Nodes"}),": Execute children in order until one fails"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fallback Nodes"}),": Execute children until one succeeds"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Decorator Nodes"}),": Modify behavior of child nodes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Action Nodes"}),": Execute specific navigation actions"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Example behavior tree structure:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Root\n\u251c\u2500\u2500 ComputePathToPose (Global Planner)\n\u251c\u2500\u2500 FollowPath (Local Controller)\n\u251c\u2500\u2500 Spin (Recovery)\n\u251c\u2500\u2500 Backup (Recovery)\n\u2514\u2500\u2500 Wait (Recovery)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"navigation-algorithms",children:"Navigation Algorithms"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 includes multiple algorithms:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Global Planners"}),": A*, NavFn, GridBasedPlanners"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Local Controllers"}),": DWA, MPC, RPP (Regulated Pure Pursuit)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recovery Behaviors"}),": Spin, Backup, Wait"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Processors"}),": VoxelGrid, InflationLayer"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"isaac-sim-integration",children:"Isaac Sim Integration"}),"\n",(0,t.jsx)(e.p,{children:"Isaac Sim provides ideal testing environments for Nav2:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"High-fidelity simulation"}),": Realistic physics and sensor models"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Ground truth data"}),": Accurate pose and map information"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Scalable testing"}),": Multiple scenarios in parallel"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safe development"}),": No risk to physical hardware"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,t.jsx)(e.p,{children:"Let's implement a complete Nav2 navigation example with Isaac Sim integration:"}),"\n",(0,t.jsx)(e.h3,{id:"nav2-configuration-nav2_configyaml",children:"Nav2 Configuration (nav2_config.yaml)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'amcl:\n  ros__parameters:\n    use_sim_time: True\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_link"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.25\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n    scan_topic: scan\n\namcl_map_client:\n  ros__parameters:\n    use_sim_time: True\n\namcl_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Specify the path where the BT XML files are located\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_goal_reached_condition_bt_node\n    - nav2_goal_updated_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_reinitialize_global_localization_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n\nbt_navigator_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Progress checker parameters\n    progress_checker:\n      plugin: "nav2_controller::SimpleProgressChecker"\n      required_movement_radius: 0.5\n      movement_time_allowance: 10.0\n\n    # Goal checker parameters\n    goal_checker:\n      plugin: "nav2_controller::SimpleGoalChecker"\n      xy_goal_tolerance: 0.25\n      yaw_goal_tolerance: 0.25\n      stateful: True\n\n    # Controller parameters\n    FollowPath:\n      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"\n      desired_linear_vel: 0.5\n      max_linear_vel: 0.5\n      min_linear_vel: 0.1\n      max_angular_vel: 1.0\n      min_angular_vel: 0.4\n      lookahead_dist: 0.6\n      lookahead_time: 1.5\n      transform_tolerance: 0.1\n      use_velocity_scaled_lookahead_dist: false\n      min_lookahead_dist: 0.3\n      max_lookahead_dist: 0.9\n      use_interpolation: true\n      use_regulated_linear_velocity: false\n      use_regulated_angular_velocity: false\n      regulated_linear_scaling_factor: 0.5\n      regulated_angular_scaling_factor: 0.2\n\ncontroller_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: True\n      rolling_window: true\n      width: 3\n      height: 3\n      resolution: 0.05\n      robot_radius: 0.22\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.05\n        z_voxels: 16\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n  local_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  local_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: True\n      robot_radius: 0.22\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n  global_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  global_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nmap_server:\n  ros__parameters:\n    use_sim_time: True\n    yaml_filename: "turtlebot3_world.yaml"\n\nmap_saver:\n  ros__parameters:\n    use_sim_time: True\n    save_map_timeout: 5.0\n    free_thresh_default: 0.25\n    occupied_thresh_default: 0.65\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: True\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n\nplanner_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nrecoveries_server:\n  ros__parameters:\n    costmap_topic: local_costmap/costmap_raw\n    footprint_topic: local_costmap/published_footprint\n    cycle_frequency: 10.0\n    recovery_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_recoveries::Spin"\n      spin_dist: 1.57\n    backup:\n      plugin: "nav2_recoveries::BackUp"\n      backup_dist: 0.15\n      backup_speed: 0.025\n    wait:\n      plugin: "nav2_recoveries::Wait"\n      wait_duration: 1.0\n\nrobot_state_publisher:\n  ros__parameters:\n    use_sim_time: True\n\nwaypoint_follower:\n  ros__parameters:\n    loop_rate: 20\n    stop_on_failure: false\n    waypoint_task_executor_plugin: "wait_at_waypoint"\n    wait_at_waypoint:\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\n      enabled: true\n      waypoint_pause_duration: 200\n'})}),"\n",(0,t.jsx)(e.h3,{id:"nav2-client-node-for-isaac-sim-nav2_clientpy",children:"Nav2 Client Node for Isaac Sim (nav2_client.py)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom rclpy.duration import Duration\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom nav2_msgs.action import NavigateToPose\nfrom std_msgs.msg import Header\nimport time\nimport math\n\n\nclass Nav2ClientNode(Node):\n    """\n    Node that interfaces with Nav2 to send navigation goals.\n    Demonstrates how to use Nav2 action interface for autonomous navigation.\n    """\n\n    def __init__(self):\n        super().__init__(\'nav2_client_node\')\n\n        # Create action client for navigation\n        self.nav_to_pose_client = ActionClient(\n            self,\n            NavigateToPose,\n            \'navigate_to_pose\'\n        )\n\n        # Create publisher for sending goals\n        self.goal_publisher = self.create_publisher(\n            PoseStamped,\n            \'/goal_pose\',\n            10\n        )\n\n        # Navigation state\n        self.navigation_active = False\n        self.goal_sequence = [\n            (1.0, 1.0, 0.0),   # x, y, theta\n            (2.0, 0.0, 1.57),  # x, y, theta\n            (1.0, -1.0, 3.14), # x, y, theta\n            (0.0, 0.0, 0.0),   # Return to start\n        ]\n        self.current_goal_index = 0\n\n        # Timer for sending navigation goals\n        self.nav_timer = self.create_timer(10.0, self.send_navigation_goal)\n\n        self.get_logger().info(\'Nav2 client node initialized\')\n\n    def send_navigation_goal(self):\n        """Send a navigation goal to Nav2."""\n        if self.current_goal_index >= len(self.goal_sequence):\n            self.get_logger().info(\'All navigation goals completed\')\n            return\n\n        # Wait for action server\n        if not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):\n            self.get_logger().error(\'Nav2 action server not available\')\n            return\n\n        # Get goal position\n        goal_x, goal_y, goal_theta = self.goal_sequence[self.current_goal_index]\n\n        # Create navigation goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = \'map\'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.pose.pose.position.x = float(goal_x)\n        goal_msg.pose.pose.position.y = float(goal_y)\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Convert theta to quaternion\n        from tf_transformations import quaternion_from_euler\n        quat = quaternion_from_euler(0, 0, goal_theta)\n        goal_msg.pose.pose.orientation.x = quat[0]\n        goal_msg.pose.pose.orientation.y = quat[1]\n        goal_msg.pose.pose.orientation.z = quat[2]\n        goal_msg.pose.pose.orientation.w = quat[3]\n\n        # Send goal\n        self.get_logger().info(f\'Sending navigation goal: ({goal_x}, {goal_y}, {goal_theta})\')\n        self.navigation_active = True\n\n        # Send async goal\n        future = self.nav_to_pose_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Add result callback\n        future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        """Handle goal response from Nav2 server."""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected by Nav2 server\')\n            self.navigation_active = False\n            return\n\n        self.get_logger().info(\'Goal accepted by Nav2 server\')\n\n        # Get result future\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        """Handle navigation result from Nav2 server."""\n        result = future.result().result\n        self.get_logger().info(f\'Navigation result: {result}\')\n\n        # Move to next goal\n        self.current_goal_index += 1\n        self.navigation_active = False\n\n        if self.current_goal_index < len(self.goal_sequence):\n            self.get_logger().info(f\'Moving to next goal #{self.current_goal_index + 1}\')\n        else:\n            self.get_logger().info(\'All navigation goals completed\')\n\n    def feedback_callback(self, feedback_msg):\n        """Handle navigation feedback from Nav2 server."""\n        feedback = feedback_msg.feedback\n        # In a real implementation, you\'d process feedback information\n        # For example, remaining distance, current speed, etc.\n        pass\n\n\ndef main(args=None):\n    """Main function to run the Nav2 client node."""\n    rclpy.init(args=args)\n\n    nav_client = Nav2ClientNode()\n\n    try:\n        rclpy.spin(nav_client)\n    except KeyboardInterrupt:\n        nav_client.get_logger().info(\'Interrupt received, shutting down...\')\n    finally:\n        nav_client.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"isaac-sim-integration-node-isaac_nav_integrationpy",children:"Isaac Sim Integration Node (isaac_nav_integration.py)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import OccupancyGrid, Odometry\nfrom geometry_msgs.msg import Twist, PoseWithCovarianceStamped\nfrom tf2_ros import TransformBroadcaster\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\nimport math\n\n\nclass IsaacNavIntegrationNode(Node):\n    """\n    Node that integrates Isaac Sim with Nav2 navigation stack.\n    Simulates robot sensors and provides interface for navigation testing.\n    """\n\n    def __init__(self):\n        super().__init__(\'isaac_nav_integration\')\n\n        # Create TF broadcaster for robot pose\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Create publishers\n        self.odom_publisher = self.create_publisher(Odometry, \'/odom\', 10)\n        self.scan_publisher = self.create_publisher(LaserScan, \'/scan\', 10)\n        self.initial_pose_publisher = self.create_publisher(\n            PoseWithCovarianceStamped,\n            \'initialpose\',\n            10\n        )\n\n        # Create subscribers for navigation commands\n        self.cmd_vel_subscriber = self.create_subscription(\n            Twist,\n            \'/cmd_vel\',\n            self.cmd_vel_callback,\n            10\n        )\n\n        # Robot state\n        self.robot_x = 0.0\n        self.robot_y = 0.0\n        self.robot_theta = 0.0\n        self.linear_velocity = 0.0\n        self.angular_velocity = 0.0\n\n        # Timer for publishing sensor data and odometry\n        self.publish_timer = self.create_timer(0.1, self.publish_sensor_data)\n\n        # Simulated environment (simplified - in real Isaac Sim, this comes from the simulator)\n        self.simulated_obstacles = [\n            (2.0, 1.0, 0.3),   # x, y, radius\n            (3.0, -1.0, 0.5),\n            (-1.0, 2.0, 0.4),\n        ]\n\n        self.get_logger().info(\'Isaac Nav integration node initialized\')\n\n    def cmd_vel_callback(self, msg):\n        """Process velocity commands from Nav2 controller."""\n        self.linear_velocity = msg.linear.x\n        self.angular_velocity = msg.angular.z\n\n    def publish_sensor_data(self):\n        """Publish simulated sensor data and odometry."""\n        # Update robot position based on velocities\n        dt = 0.1  # 10Hz\n        self.robot_x += self.linear_velocity * math.cos(self.robot_theta) * dt\n        self.robot_y += self.linear_velocity * math.sin(self.robot_theta) * dt\n        self.robot_theta += self.angular_velocity * dt\n\n        # Publish odometry\n        self.publish_odometry()\n\n        # Publish laser scan\n        self.publish_laser_scan()\n\n        # Publish TF\n        self.publish_transform()\n\n    def publish_odometry(self):\n        """Publish odometry data."""\n        odom_msg = Odometry()\n        odom_msg.header.frame_id = \'odom\'\n        odom_msg.header.stamp = self.get_clock().now().to_msg()\n        odom_msg.child_frame_id = \'base_link\'\n\n        odom_msg.pose.pose.position.x = self.robot_x\n        odom_msg.pose.pose.position.y = self.robot_y\n        odom_msg.pose.pose.position.z = 0.0\n\n        # Convert angle to quaternion\n        from tf_transformations import quaternion_from_euler\n        quat = quaternion_from_euler(0, 0, self.robot_theta)\n        odom_msg.pose.pose.orientation.x = quat[0]\n        odom_msg.pose.pose.orientation.y = quat[1]\n        odom_msg.pose.pose.orientation.z = quat[2]\n        odom_msg.pose.pose.orientation.w = quat[3]\n\n        odom_msg.twist.twist.linear.x = self.linear_velocity\n        odom_msg.twist.twist.angular.z = self.angular_velocity\n\n        self.odom_publisher.publish(odom_msg)\n\n    def publish_laser_scan(self):\n        """Publish simulated laser scan data."""\n        scan_msg = LaserScan()\n        scan_msg.header.frame_id = \'laser_frame\'\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\n\n        # Laser scan parameters\n        scan_msg.angle_min = -math.pi\n        scan_msg.angle_max = math.pi\n        scan_msg.angle_increment = 2 * math.pi / 360  # 1 degree resolution\n        scan_msg.time_increment = 0.0\n        scan_msg.scan_time = 0.1\n        scan_msg.range_min = 0.1\n        scan_msg.range_max = 10.0\n\n        # Generate ranges by checking for obstacles at different angles\n        ranges = []\n        num_scans = 360\n\n        for i in range(num_scans):\n            angle = scan_msg.angle_min + i * scan_msg.angle_increment\n\n            # Calculate ray endpoint in robot\'s local frame\n            ray_x = math.cos(angle) * scan_msg.range_max\n            ray_y = math.sin(angle) * scan_msg.range_max\n\n            # Transform to global frame\n            global_ray_x = self.robot_x + ray_x * math.cos(self.robot_theta) - ray_y * math.sin(self.robot_theta)\n            global_ray_y = self.robot_y + ray_x * math.sin(self.robot_theta) + ray_y * math.cos(self.robot_theta)\n\n            # Check for obstacles along this ray\n            min_distance = scan_msg.range_max\n            for obs_x, obs_y, obs_radius in self.simulated_obstacles:\n                # Calculate distance from robot to obstacle\n                dist_to_obs = math.sqrt((obs_x - self.robot_x)**2 + (obs_y - self.robot_y)**2)\n\n                # If obstacle is in direction of ray and closer than max range\n                obs_angle = math.atan2(obs_y - self.robot_y, obs_x - self.robot_x)\n                angle_diff = abs(angle - self.robot_theta - obs_angle)\n                if angle_diff > math.pi:\n                    angle_diff = 2 * math.pi - angle_diff\n\n                if angle_diff < 0.1 and dist_to_obs < min_distance:  # 0.1 rad ~ 5.7 deg cone\n                    # Calculate intersection distance\n                    distance = math.sqrt((obs_x - self.robot_x)**2 + (obs_y - self.robot_y)**2) - obs_radius\n                    if distance > 0 and distance < min_distance:\n                        min_distance = distance\n\n            ranges.append(min_distance)\n\n        scan_msg.ranges = ranges\n        self.scan_publisher.publish(scan_msg)\n\n    def publish_transform(self):\n        """Publish TF transform from odom to base_link."""\n        from geometry_msgs.msg import TransformStamped\n\n        t = TransformStamped()\n        t.header.stamp = self.get_clock().now().to_msg()\n        t.header.frame_id = \'odom\'\n        t.child_frame_id = \'base_link\'\n\n        t.transform.translation.x = self.robot_x\n        t.transform.translation.y = self.robot_y\n        t.transform.translation.z = 0.0\n\n        from tf_transformations import quaternion_from_euler\n        quat = quaternion_from_euler(0, 0, self.robot_theta)\n        t.transform.rotation.x = quat[0]\n        t.transform.rotation.y = quat[1]\n        t.transform.rotation.z = quat[2]\n        t.transform.rotation.w = quat[3]\n\n        self.tf_broadcaster.sendTransform(t)\n\n\ndef main(args=None):\n    """Main function to run the Isaac Nav integration node."""\n    rclpy.init(args=args)\n\n    integration_node = IsaacNavIntegrationNode()\n\n    try:\n        rclpy.spin(integration_node)\n    except KeyboardInterrupt:\n        integration_node.get_logger().info(\'Interrupt received, shutting down...\')\n    finally:\n        integration_node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"launch-file-for-nav2-isaac-integration-nav2_isaac_launchpy",children:"Launch File for Nav2 Isaac Integration (nav2_isaac_launch.py)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, TimerAction\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    # Launch configuration\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    params_file = LaunchConfiguration('params_file')\n\n    # Declare launch arguments\n    declare_use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='True',\n        description='Use simulation (Gazebo) clock if true'\n    )\n\n    declare_params_file = DeclareLaunchArgument(\n        'params_file',\n        default_value=os.path.join(\n            FindPackageShare('isaac_nav_examples').find('isaac_nav_examples'),\n            'config',\n            'nav2_config.yaml'\n        ),\n        description='Full path to params file for Nav2 nodes'\n    )\n\n    # Include Nav2 launch file\n    nav2_launch = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('nav2_bringup'),\n                'launch',\n                'navigation_launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'use_sim_time': use_sim_time,\n            'params_file': params_file\n        }.items()\n    )\n\n    # Isaac Nav integration node\n    isaac_integration_node = Node(\n        package='isaac_nav_examples',\n        executable='isaac_nav_integration',\n        name='isaac_nav_integration',\n        parameters=[{'use_sim_time': use_sim_time}],\n        output='screen'\n    )\n\n    # Nav2 client node\n    nav_client_node = Node(\n        package='isaac_nav_examples',\n        executable='nav2_client',\n        name='nav2_client',\n        parameters=[{'use_sim_time': use_sim_time}],\n        output='screen'\n    )\n\n    # RViz2 for visualization\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        arguments=['-d', PathJoinSubstitution([\n            FindPackageShare('isaac_nav_examples'),\n            'rviz',\n            'nav2_isaac_config.rviz'\n        ])],\n        parameters=[{'use_sim_time': use_sim_time}],\n        output='screen'\n    )\n\n    # Create launch description\n    ld = LaunchDescription()\n\n    # Add launch arguments\n    ld.add_action(declare_use_sim_time)\n    ld.add_action(declare_params_file)\n\n    # Add nodes with proper timing\n    ld.add_action(nav2_launch)\n    ld.add_action(isaac_integration_node)\n    ld.add_action(nav_client_node)\n    ld.add_action(rviz_node)\n\n    return ld\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[INFO] [nav2_client_node]: Nav2 client node initialized\n[INFO] [nav2_client_node]: Sending navigation goal: (1.0, 1.0, 0.0)\n[INFO] [nav2_client_node]: Goal accepted by Nav2 server\n[INFO] [isaac_nav_integration]: Isaac Nav integration node initialized\n[INFO] [nav2_client_node]: Navigation result: succeeded\n[INFO] [nav2_client_node]: Moving to next goal #2\n[INFO] [isaac_nav_integration]: Published simulated scan with 360 ranges\n[INFO] [isaac_nav_integration]: Robot pose: (1.25, 0.87, 0.12)\n[INFO] [nav2_client_node]: All navigation goals completed\n[INFO] [nav2_client_node]: Interrupt received, shutting down...\n"})}),"\n",(0,t.jsx)(e.h3,{id:"running-the-example",children:"Running the Example"}),"\n",(0,t.jsx)(e.p,{children:"To run this Nav2 navigation example with Isaac Sim:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Terminal 1: Source ROS 2 and navigation packages\nsource /opt/ros/humble/setup.bash\nsource /usr/share/isaac_ros_common/setup.bash\n\n# Terminal 2: Launch Nav2 with Isaac integration\nros2 launch isaac_nav_examples nav2_isaac_launch.py\n\n# Terminal 3: Send additional navigation goals manually\nros2 run nav2_msgs navigate_to_pose \\\n  --x 3.0 --y 2.0 --yaw 1.57\n\n# Terminal 4: Monitor navigation status\nros2 topic echo /navigate_to_pose/_action/status\n\n# Terminal 5: Visualize in RViz2\n# In RViz2, add displays for: Map, LaserScan, Path, Pose, Local/Global Costmaps\n\n# Example of sending a goal programmatically:\n# ros2 run isaac_nav_examples send_goal --x 5.0 --y 5.0 --theta 0.0\n"})}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(e.h3,{id:"exercise-1-navigation-parameter-tuning",children:"Exercise 1: Navigation Parameter Tuning"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Task"}),": Tune Nav2 parameters for different robot types and environments."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Modify Nav2 configuration for a larger robot (e.g., delivery robot)"}),"\n",(0,t.jsx)(e.li,{children:"Adjust costmap inflation and resolution parameters"}),"\n",(0,t.jsx)(e.li,{children:"Tune controller parameters for different speeds and dynamics"}),"\n",(0,t.jsx)(e.li,{children:"Test navigation performance in various scenarios"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Success Criteria"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Parameters properly configured for different robot sizes"}),"\n",(0,t.jsx)(e.li,{children:"Navigation works safely in various environments"}),"\n",(0,t.jsx)(e.li,{children:"Performance metrics collected and compared"}),"\n",(0,t.jsx)(e.li,{children:"Understanding of parameter impact on navigation"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-2-behavior-tree-customization",children:"Exercise 2: Behavior Tree Customization"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Task"}),": Create custom behavior tree nodes for specialized navigation."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Implement a custom behavior tree node for specific recovery behavior"}),"\n",(0,t.jsx)(e.li,{children:"Add the node to the Nav2 behavior tree system"}),"\n",(0,t.jsx)(e.li,{children:"Test the custom behavior in simulation"}),"\n",(0,t.jsx)(e.li,{children:"Document the new behavior and its use cases"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Success Criteria"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Custom behavior tree node implemented and registered"}),"\n",(0,t.jsx)(e.li,{children:"Node integrates properly with Nav2 system"}),"\n",(0,t.jsx)(e.li,{children:"Behavior works as expected in simulation"}),"\n",(0,t.jsx)(e.li,{children:"New functionality properly documented"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-3-isaac-sim-navigation-testing",children:"Exercise 3: Isaac Sim Navigation Testing"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Task"}),": Create comprehensive navigation tests in Isaac Sim."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Design multiple test scenarios with different obstacles and layouts"}),"\n",(0,t.jsx)(e.li,{children:"Implement automated testing scripts for navigation"}),"\n",(0,t.jsx)(e.li,{children:"Collect performance metrics (success rate, time, path efficiency)"}),"\n",(0,t.jsx)(e.li,{children:"Analyze navigation performance across scenarios"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Success Criteria"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Multiple test scenarios created in Isaac Sim"}),"\n",(0,t.jsx)(e.li,{children:"Automated testing framework implemented"}),"\n",(0,t.jsx)(e.li,{children:"Performance metrics collected and analyzed"}),"\n",(0,t.jsx)(e.li,{children:"Navigation system validated across scenarios"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 provides a comprehensive navigation stack for ROS 2 that enables autonomous robot navigation in complex environments. We've explored the modular architecture of Nav2, including global and local planners, controllers, and recovery behaviors. The system integrates perception, planning, and control to create robust navigation capabilities that work with SLAM-generated maps."}),"\n",(0,t.jsx)(e.p,{children:"We've implemented examples showing Nav2 configuration, client interfaces for sending navigation goals, and integration with Isaac Sim for testing. The examples demonstrated how to set up navigation systems, send goals, process sensor data, and monitor navigation progress."}),"\n",(0,t.jsx)(e.p,{children:"Understanding Nav2 is crucial for Physical AI systems that need to move autonomously through environments. The combination of global path planning and local obstacle avoidance enables robots to operate safely and efficiently in dynamic environments."}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(e.p,{children:"Now that you understand Nav2 navigation, the next chapter explores sim-to-real transfer principles. You'll learn how to effectively transfer navigation behaviors and models from simulation to real robots, addressing the reality gap and ensuring successful deployment."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Next Chapter"}),": Module 3, Chapter 4: Sim-to-Real Transfer Principles"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(_,{...n})}):_(n)}}}]);